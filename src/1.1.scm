(use slib)
(require 'trace)

; 強力な言語は三つの仕掛けがある。p2
;
; * 基本式 言語が関わる最も単純ななもの表す
; * 組み合わせ法 より単純なのから合成物をつくる
; * 抽象化法 合成物に名をつけ、単一のものとして扱う

;1.1.1 式 p3
;~~~~~~~~~~~~~~~~~~~
(print "1.1.1--------------------------------------------------------")
(print (+ 137 349))
(print (- 1000 334))
(print (* 5 99))
(print (/ 10 5))
(print (+ 2.7 10))
(print (+ 21 35 12 7))
(print (+ 25 4 12 ))
(print (+ (* 3 5)(- 10 6)))
(print (+ (* 3(+ (* 2 4)(+ 3 5))) (+ (- 10 7) 6)))

;清書系
(print (+ (* 3
            (+ (* 2 4)
               (+ 3 5))) 
          (+ (- 10 7) 
             6)))

;メモ
;+++++++++++++++++++
;
;* 前置記法(prefix notation)

;1.1.2 名前と環境
;~~~~~~~~~~~~~~~~~~~
(print "1.1.2--------------------------------------------------------")

(define size 2)
(print size)

(print (* 5 size))

(define pi 3.14159)
(define radius 10)

(print (* pi (* radius radius)))

(define circumference (* 2 pi radius))

(print circumference)

;1.1.3 組み合わせの評価
;~~~~~~~~~~~~~~~~~~~~~~~~~
;
;組み合わせの評価
;
;1. 組み合わせの部分式を評価する
;2. 最左部分式のである手続き(演算子)を残りの部分式の値である(被演算子)に作用させる
;
;評価の規則は本質的に再帰的(recursive)である。
;
;実際、評価規則の「値が上方へわき出す」形は"木構造の溜め込み"(tree accumulation)
;として知られている
;
(print "1.1.3--------------------------------------------------------")

(print (* (+ 2 (* 4 6))
          (+ 3 5 7)))

;(define x 3)の評価はdefineを二つの引数(一方はx の値で、もう一方は3)に作用させるのではない。
;defineの目的はxに値を対応づけることでしかない。つまり(define x 3)は組み合わせではない。
;このような一般的評価規則の例外を特殊形式(special forms)と呼ぶ
;
;Lisp はとても単純な構文規則を持っている。つまり、式の評価規則は単純な一般規則と、少数の
;特殊形式に特化した規則で出来ている。


;1.1.4 合成手続き
;~~~~~~~~~~~~~~~~~~~~~~~~~
;
;* 数と算術演算子は基本的データと手続きである。
;* 組み合わせの入れ子は演算のを組み合わせる手段である。
;* 名前と値を対応づける定義は抽象のそこそこの手段である。
;
;手続き定義(procedure definitions)を学ぼう
(print "1.1.4--------------------------------------------------------")

(define (square x) (* x x))

(print (square 21))
(print (square (+ 2 5)))
(print (square (square 3)))

(define (sum-of-squares x y)
    (+ (square x) (square y)))

(print (sum-of-squares 3 4))

(define (f a)
    (sum-of-squares (+ a 1) (* a 2)))

(print (f 5))
; 合成手続きは基本手続きとまったく同様に使う事ができる

;1.1.5 手続き作用の置き換えモデル
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(print "1.1.5--------------------------------------------------------")

(trace f)
(trace sum-of-squares)
(trace square)
(f 5)

;(f 5)
;(sum-of-squares(+ a 1) (* a 2))
;(+ (square 6) (square 10))
;(+ (* 6 6) (* 10 10))
;(+ 36 100)
;136
;
;このようなプロセスを、手続き作用の置き換えモデル(substitution model)という。
;手続き作用の意味を定めるもモデル
;
;* 置き換えの目的は、手続きを考える上での補助であって実際の動きを述べるものではない。
;* 置き換えモデルは評価プロセスを形式的に考える第一歩
;

; 作用順序と正規順序
;
;「完全に展開し、簡約する」評価方法を"正規順序の評価"(normal-order evaluation)
;「引数を評価し、作用させる」評価方法を"作用的順序の評価"(applicative-order evaluation)
;
;Lipは作用的順序の評価

;1.1.6 条件式と述語
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
;場合分け(case analysis)
;cond(conditinal(条件付き))
;
(print "1.1.6--------------------------------------------------------")

(define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0) 
          ((< x 0) (- x))))

(print (abs -10))

; cond に続けて節(clauses)とう括弧に入った式の対(<p> <c>)
; 対の最初の式<p>を述語(predicate)という = 値を真か偽と解釈する式
; <c> は 節に対応する帰結式(consequent expression)
;
; 述語という用語は、「真と偽に評価される式」と同様、「真か偽を返す手続き」にも使う

(define (abs2 x)
    (cond ((< x 0) (- x))
    (else x)))

(print (abs2 -10))

(define (abs3 x)
    (if (< x 0)
        (- x)
        x))

(print (abs3 -10))

(define (is_range x)
    (and (> x 5) (< x 10)))
(print (is_range 7))
(print (is_range 3))

(define (>= x y)
    (or (> x y) (= x y)))

(print (>= 5 5))
(print (>= 5 6))

(define (>= x y)
    (not (< x y)))

(print (>= 5 5))
(print (>= 5 6))


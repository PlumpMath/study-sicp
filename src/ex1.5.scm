(use slib)
(require 'trace)

(define (p) (p))
(define (test x y)
    (if (= x 0)
        0
        y))

(trace p)
(print (test 0 (p)))

;作用的順序 -> 引数を評価し、作用せせながら展開
;正規順序 -> 完全に式を展開し、簡約する。
;
;1. 作用的順序の場合、関数を呼び出した時点で、
;Pを評価しようとして、無限ループに陥ってしまう。
;
;(test 0 (p))
;CALL p
;  CALL p
;    CALL p
;      CALL p
;         CALL p

;2. 正規順序の場合、完全に展開してから簡約にするので
;関数呼び出し時点では、(p)は評価されずに、if文に到達し、
;xを評価して=0 なので、0を返す。
;x=0が成り立たなければ、y に分岐するので、この時点で(p)の
;評価が行われ(p)の無限ループに陥る可能性はある。
;
